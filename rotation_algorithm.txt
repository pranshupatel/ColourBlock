(This file is best viewed in a fixed-width font.)

-----

Clockwise rotation of blocks:

 Each block starts with its initial nodes, and rotation moves all its nodes to other locations on the grid.

I-block:
(0,4), (1,4), (2,4), (3,4) => (1,3), (1,4), (1,5), (1,6) => (0,5), (1,5), (2,5), (3,5) => (2,3), (2,4), (2,5), (2,6)

# So for node 1 in the I-block, (0,4) becomes (1,3) becomes (0,5) becomes (2,3) becomes (0,4) and so on.

L-block:
(0,5), (1,5), (2,5), (2,4) => (1,6), (1,5), (1,4), (0,4) => (2,5), (1,5), (0,5), (0,6) => (1,4), (1,5), (1,6), (2,6)

L_opp-block:
(0,4), (1,4), (2,4), (2,5) => (1,5), (1,4), (1,3), (2,3) => (2,4), (1,4), (0,4), (0,3) => (1,3), (1,4), (1,5), (0,5)

T-block:
(0,4), (1,3), (1,4), (1,5) => (1,5), (0,4), (1,4), (2,4) => (2,4), (1,5), (1,4), (1,3) => (1,3), (2,4), (1,4), (0,4)

Z-block:
(0,4), (0,5), (1,5), (1,6) => (0,6), (1,6), (1,5), (2,5) => (2,6), (2,5), (1,5), (1,4) => (2,4), (1,4), (1,5), (0,5)

Z_opp-block:
(0,5), (0,4), (1,4), (1,3) => (2,5), (1,5), (1,4), (0,4) => (2,3), (2,4), (1,4), (1,5) => (0,3), (1,3), (1,4), (2,4)

-----

Algorithms/mechanisms for clockwise rotation of blocks:

 Since the blocks move down row by row, we need to know how the rotations change each node's coordinates.
 Assigning "rotation states" to each block helps keep track of where to put each node on the next rotation.
 From here, we can detail the change in nodes to implement rotation of blocks.

I-block:

1: (0,4), (1,4), (2,4), (3,4) ... 4 to 1: (-2,+1), (-1, 0), ( 0,-1), (+1,-2)
2: (1,3), (1,4), (1,5), (1,6) ... 1 to 2: (+1,-1), ( 0, 0), (-1,+1), (-2,+2)
3: (0,5), (1,5), (2,5), (3,5) ... 2 to 3: (-1,+2), ( 0,+1), (+1, 0), (+2,-1)
4: (2,3), (2,4), (2,5), (2,6) ... 3 to 4: (+2,-2), (+1,-1), ( 0, 0), (-1,+1)

L-block:

1: (0,5), (1,5), (2,5), (2,4) ... 4 to 1: (-1,+1), ( 0, 0), (+1,-1), ( 0,-2)
2: (1,6), (1,5), (1,4), (0,4) ... 1 to 2: (+1,+1), ( 0, 0), (-1,-1), (-2, 0)
3: (2,5), (1,5), (0,5), (0,6) ... 2 to 3: (+1,-1), ( 0, 0), (-1,+1), ( 0,+2)
4: (1,4), (1,5), (1,6), (2,6) ... 3 to 4: (-1,-1), ( 0, 0), (+1,+1), (+2, 0)

L_opp-block:

1: (0,4), (1,4), (2,4), (2,5) ... 4 to 1: (-1,+1), ( 0, 0), (+1,-1), (+2, 0)
2: (1,5), (1,4), (1,3), (2,3) ... 1 to 2: (+1,+1), ( 0, 0), (-1,-1), ( 0,-2)
3: (2,4), (1,4), (0,4), (0,3) ... 2 to 3: (+1,-1), ( 0, 0), (-1,+1), (-2, 0)
4: (1,3), (1,4), (1,5), (0,5) ... 3 to 4: (-1,-1), ( 0, 0), (+1,+1), ( 0,+2)

T-block:

1: (0,4), (1,3), (1,4), (1,5) ... 4 to 1: (-1,+1), (-1,-1), ( 0, 0), (+1,+1)
2: (1,5), (0,4), (1,4), (2,4) ... 1 to 2: (+1,+1), (-1,+1), ( 0, 0), (+1,-1)
3: (2,4), (1,5), (1,4), (1,3) ... 2 to 3: (+1,-1), (+1,+1), ( 0, 0), (-1,-1)
4: (1,3), (2,4), (1,4), (0,4) ... 3 to 4: (-1,-1), (+1,-1), ( 0, 0), (-1,+1)

Z-block:

1: (0,4), (0,5), (1,5), (1,6) ... 4 to 1: (-2, 0), (-1,+1), ( 0, 0), (+1,+1)
2: (0,6), (1,6), (1,5), (2,5) ... 1 to 2: ( 0,+2), (+1,+1), ( 0, 0), (+1,-1)
3: (2,6), (2,5), (1,5), (1,4) ... 2 to 3: (+2, 0), (+1,-1), ( 0, 0), (-1,-1)
4: (2,4), (1,4), (1,5), (0,5) ... 3 to 4: ( 0,-2), (-1,-1), ( 0, 0), (-1,+1)

Z_opp-block:

1: (0,5), (0,4), (1,4), (1,3) ... 4 to 1: ( 0,+2), (-1,+1), ( 0, 0), (-1,-1)
2: (2,5), (1,5), (1,4), (0,4) ... 1 to 2: (+2, 0), (+1,+1), ( 0, 0), (-1,+1)
3: (2,3), (2,4), (1,4), (1,5) ... 2 to 3: ( 0,-2), (+1,-1), ( 0, 0), (+1,+1)
4: (0,3), (1,3), (1,4), (2,4) ... 3 to 4: (-2, 0), (-1,-1), ( 0, 0), (+1,-1)

-----

Counter-clockwise rotation of blocks:

 Each block starts with its initial nodes, and rotation moves all its nodes to other locations on the grid.

I-block:
(0,4), (1,4), (2,4), (3,4) => (2,3), (2,4), (2,5), (2,6) => (0,5), (1,5), (2,5), (3,5) => (1,3), (1,4), (1,5), (1,6)

L-block:
(0,5), (1,5), (2,5), (2,4) => (1,4), (1,5), (1,6), (2,6) => (2,5), (1,5), (0,5), (0,6) => (1,6), (1,5), (1,4), (0,4)

L_opp-block:
(0,4), (1,4), (2,4), (2,5) => (1,3), (1,4), (1,5), (0,5) => (2,4), (1,4), (0,4), (0,3) => (1,5), (1,4), (1,3), (2,3)

T-block:
(0,4), (1,3), (1,4), (1,5) => (1,3), (2,4), (1,4), (0,4) => (2,4), (1,5), (1,4), (1,3) => (1,5), (0,4), (1,4), (2,4)

Z-block:
(0,4), (0,5), (1,5), (1,6) => (2,4), (1,4), (1,5), (0,5) => (2,6), (2,5), (1,5), (1,4) => (0,6), (1,6), (1,5), (2,5)

Z_opp-block:
(0,5), (0,4), (1,4), (1,3) => (0,3), (1,3), (1,4), (2,4) => (2,3), (2,4), (1,4), (1,5) => (2,5), (1,5), (1,4), (0,4)

-----

Algorithms/mechanisms for counter-clockwise rotation of blocks:

 Since the blocks move down row by row, we need to know how the rotations change each node's coordinates.
 Assigning "rotation states" to each block helps keep track of where to put each node on the next rotation.
 From here, we can detail the change in nodes to implement rotation of blocks.

I-block:
1: (0,4), (1,4), (2,4), (3,4) ... 2 to 1: (-1,+1), ( 0, 0), (+1,-1), (+2,-2)
4: (2,3), (2,4), (2,5), (2,6) ... 1 to 4: (+2,-1), (+1, 0), ( 0,+1), (-1,+2)
3: (0,5), (1,5), (2,5), (3,5) ... 4 to 3: (-2,+2), (-1,+1), ( 0, 0), (+1,-1)
2: (1,3), (1,4), (1,5), (1,6) ... 3 to 2: (+1,-2), ( 0,-1), (-1, 0), (-2,+1)

L-block:
1: (0,5), (1,5), (2,5), (2,4) ... 2 to 1: (-1,-1), ( 0, 0), (+1,+1), (+2, 0)
4: (1,4), (1,5), (1,6), (2,6) ... 1 to 4: (+1,-1), ( 0, 0), (-1,+1), ( 0,+2)
3: (2,5), (1,5), (0,5), (0,6) ... 4 to 3: (+1,+1), ( 0, 0), (-1,-1), (-2, 0)
2: (1,6), (1,5), (1,4), (0,4) ... 3 to 2: (-1,+1), ( 0, 0), (+1,-1), ( 0,+2)

L_opp-block:
1: (0,4), (1,4), (2,4), (2,5) ... 2 to 1: (-1,-1), ( 0, 0), (+1,+1), ( 0,+2)
4: (1,3), (1,4), (1,5), (0,5) ... 1 to 4: (+1,-1), ( 0, 0), (-1,+1), (-2, 0)
3: (2,4), (1,4), (0,4), (0,3) ... 4 to 3: (+1,+1), ( 0, 0), (-1,-1), ( 0,-2)
2: (1,5), (1,4), (1,3), (2,3) ... 3 to 2: (-1,+1), ( 0, 0), (+1,-1), (+2, 0)

T-block:
1: (0,4), (1,3), (1,4), (1,5) ... 2 to 1: (-1,-1), (+1,-1), ( 0, 0), (-1,+1)
4: (1,3), (2,4), (1,4), (0,4) ... 1 to 4: (+1,-1), (+1,+1), ( 0, 0), (-1,-1)
3: (2,4), (1,5), (1,4), (1,3) ... 4 to 3: (+1,+1), (-1,+1), ( 0, 0), (+1,-1)
2: (1,5), (0,4), (1,4), (2,4) ... 3 to 2: (-1,+1), (-1,-1), ( 0, 0), (+1,+1)

Z-block:
1: (0,4), (0,5), (1,5), (1,6) ... 2 to 1: ( 0,-2), (-1,-1), ( 0, 0), (-1,+1)
4: (2,4), (1,4), (1,5), (0,5) ... 1 to 4: (+2, 0), (+1,-1), ( 0, 0), (-1,-1)
3: (2,6), (2,5), (1,5), (1,4) ... 4 to 3: ( 0,+2), (+1,+1), ( 0, 0), (+1,-1)
2: (0,6), (1,6), (1,5), (2,5) ... 3 to 2: (-2, 0), (-1,+1), ( 0, 0), (+1,+1)

Z_opp-block:
1: (0,5), (0,4), (1,4), (1,3) ... 2 to 1: (-2, 0), (-1,-1), ( 0, 0), (+1,-1)
4: (0,3), (1,3), (1,4), (2,4) ... 1 to 4: ( 0,-2), (+1,-1), ( 0, 0), (+1,+1)
3: (2,3), (2,4), (1,4), (1,5) ... 4 to 3: (+2, 0), (+1,+1), ( 0, 0), (-1,+1)
2: (2,5), (1,5), (1,4), (0,4) ... 3 to 2: ( 0,+2), (-1,+1), ( 0, 0), (-1,-1)

-----

Example codes to implement rotation:

# helper function for moving nodes during rotation
def shift_node(node, x, y) -> None:
    # node: node to be shifted
    # x: change in x (horizontal shift)
    # y: change in y (vertical shift)

# clockwise rotation of I-block
if rotate_state == 1:
    # 1 to 2
    rotate_state = 2
    shift_node(node1, 1, -1)
    shift_node(node3, -1, 1)
    shift_node(node4, -2, 2)
elif rotate_state == 2:
    # 2 to 3
    rotate_state = 3
    shift_node(node1, -1, 2)
    shift_node(node2, 0, 1)
    shift_node(node3, 1, 0)
    shift_node(node4, 2, -1)
elif rotate_state == 3:
    # 3 to 4
    rotate_state = 4
    shift_node(node1, 2, -2)
    shift_node(node2, 1, -1)
    shift_node(node4, -1, 1)
elif rotate_state == 4:
    # 4 to 1
    rotate_state = 1
    shift_node(node1, -2, 1)
    shift_node(node2, -1, 0)
    shift_node(node3, 0, -1)
    shift_node(node4, 1, -2)

# clockwise rotation of L-block
if rotate_state == 1:
    # 1 to 2
    rotate_state = 2
    shift_node(node1, 1, 1)
    shift_node(node3, -1, -1)
    shift_node(node4, -2, 0)
elif rotate_state == 2:
    # 2 to 3
    rotate_state = 3
    shift_node(node1, 1, -1)
    shift_node(node3, -1, -1)
    shift_node(node4, 0, 2)
elif rotate_state == 3:
    # 3 to 4
    rotate_state = 4
    shift_node(node1, -1, -1)
    shift_node(node3, -1, 1)
    shift_node(node4, 2, 0)
elif rotate_state == 4:
    # 4 to 1
    rotate_state = 1
    shift_node(node1, -1, 1)
    shift_node(node3, 1, 1)
    shift_node(node4, 0, -2)